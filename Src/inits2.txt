

#include "main.h"


void init_ports(void){
  
	GPIO_InitTypeDef  GPIO_InitStructure;
 
	/***** Clock enable *****/
  
	// GPIOA clock enable
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);

	// GPIOB clock enable
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOBEN);

	// GPIOC clock enable
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOCEN);

	// SYSCFG clock enable
	SET_BIT(RCC->AHBENR, RCC_APB2ENR_SYSCFGEN);


#ifdef USE_INDICATION_BOARD 	
	/***** LEDs *****/
	
	/* 
	 PB3  = LED_1
	 PB4  = LED_2
	 PB5  = LED_3
	*/
	// Configure IOs in output push-pull mode to drive external LEDs 
			
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOBEN); 
	CLEAR_BIT(GPIOB->MODER, GPIO_MODER_MODER3|GPIO_MODER_MODER4|GPIO_MODER_MODER5);
	SET_BIT(GPIOB->MODER, GPIO_MODER_MODER3_0|GPIO_MODER_MODER4_0|GPIO_MODER_MODER5_0);
	
	CLEAR_BIT(GPIOB->OTYPER, (GPIO_OTYPER_OT_3|GPIO_OTYPER_OT_4|GPIO_OTYPER_OT_5));
	CLEAR_BIT(GPIOB->OSPEEDR,(GPIO_OSPEEDER_OSPEEDR3|GPIO_OSPEEDER_OSPEEDR4|GPIO_OSPEEDER_OSPEEDR5));
	CLEAR_BIT(GPIOB->PUPDR, (GPIO_PUPDR_PUPDR3|GPIO_PUPDR_PUPDR4|GPIO_PUPDR_PUPDR5));
			
	/***** Buttons *****/
					
	/* 
	 PB3  = BUTTON_1
	 PB4  = BUTTON_2
	*/
			
	// Configure PB3, PB4 in input mode
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOBEN); 
	CLEAR_BIT(GPIOB->MODER, (GPIO_MODER_MODER8_0|GPIO_MODER_MODER9_0));
	CLEAR_BIT(GPIOB->PUPDR,(GPIO_PUPDR_PUPDR8|GPIO_PUPDR_PUPDR9));
#else
			/***** USER PINs 	*****/
				
			// Configure IOs in output push-pull mode 
			GPIO_InitStructure.Pin	 = USER_PIN_1 | USER_PIN_2 | USER_PIN_3 | USER_PIN_4 | USER_PIN_5;
			GPIO_InitStructure.Mode  = GPIO_MODE_OUTPUT_PP;
			GPIO_InitStructure.Pull  = GPIO_NOPULL;
			GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
			HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
#endif
	
	/***** NTC Relay PA15 *****/
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);
	
	CLEAR_BIT(GPIOA->MODER,GPIO_MODER_MODER15);
	SET_BIT(GPIOA->MODER, GPIO_MODER_MODER15_0);
	
	CLEAR_BIT(GPIOA->OTYPER, (GPIO_OTYPER_OT_15));	
	SET_BIT(GPIOA->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR15));
	
	CLEAR_BIT(GPIOA->PUPDR,   (GPIO_PUPDR_PUPDR15));
	

  /***** PWM outputs *****/
      
       /* 
         PA8  = HIN_U
         PA9  = HIN_V 
         PA10 = HIN_W
         PB13 = LIN_U
         PB14 = LIN_V 
         PB15 = LIN_W
      */

      // Configure PA8-PA10 in TIM1 Alternate Function mode  

	  
	SET_BIT(RCC->AHBENR,     RCC_AHBENR_GPIOAEN); 
	
	CLEAR_BIT(GPIOA->MODER,  GPIO_MODER_MODER8|GPIO_MODER_MODER9|GPIO_MODER_MODER10);
	SET_BIT(GPIOA->MODER,    GPIO_MODER_MODER8_1|GPIO_MODER_MODER9_1|GPIO_MODER_MODER10_1);
	
	CLEAR_BIT(GPIOA->OTYPER,(GPIO_OTYPER_OT_8|GPIO_OTYPER_OT_9|GPIO_OTYPER_OT_10));
	
	CLEAR_BIT(GPIOA->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR8|GPIO_OSPEEDER_OSPEEDR9|GPIO_OSPEEDER_OSPEEDR10));
	SET_BIT(GPIOA->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR8|GPIO_OSPEEDER_OSPEEDR9|GPIO_OSPEEDER_OSPEEDR10));
	
	CLEAR_BIT(GPIOA->PUPDR, (GPIO_PUPDR_PUPDR8|GPIO_PUPDR_PUPDR9|GPIO_PUPDR_PUPDR10));
  
	MODIFY_REG(GPIOA->AFR[1],GPIO_AFRH_AFRH0_Msk,(6 << GPIO_AFRH_AFRH0_Pos));
	MODIFY_REG(GPIOA->AFR[1],GPIO_AFRH_AFRH1_Msk,(6 << GPIO_AFRH_AFRH1_Pos));
	MODIFY_REG(GPIOA->AFR[1],GPIO_AFRH_AFRH2_Msk,(6 << GPIO_AFRH_AFRH2_Pos));
	
      
    // Configure PB13-PB15 in TIM1 Alternate Function mode  
	  
	  
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOBEN); 
	SET_BIT(GPIOB->MODER, GPIO_MODER_MODER13_1|GPIO_MODER_MODER14_1|GPIO_MODER_MODER15_1);
	CLEAR_BIT(GPIOB->OTYPER, (GPIO_OTYPER_OT_13|GPIO_OTYPER_OT_14|GPIO_OTYPER_OT_15));
	SET_BIT(GPIOB->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR13|GPIO_OSPEEDER_OSPEEDR14|GPIO_OSPEEDER_OSPEEDR15));
	CLEAR_BIT(GPIOB->PUPDR, (GPIO_PUPDR_PUPDR13|GPIO_PUPDR_PUPDR14|GPIO_PUPDR_PUPDR15));
  
	MODIFY_REG(GPIOB->AFR[1],GPIO_AFRH_AFRH5_Msk,(6 << GPIO_AFRH_AFRH5_Pos));
	MODIFY_REG(GPIOB->AFR[1],GPIO_AFRH_AFRH6_Msk,(6 << GPIO_AFRH_AFRH6_Pos));
	MODIFY_REG(GPIOB->AFR[1],GPIO_AFRH_AFRH7_Msk,(4 << GPIO_AFRH_AFRH7_Pos));
      
			
	/***** Other *****/
    /* 
	 PA0   = THERM
	 PA11  = VFO
	 PA12  = ITRIP
	*/
			
	// Configure thermistor input in analog mode 
				
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN); 
	SET_BIT(GPIOA->MODER,  GPIO_MODER_MODER0);
	CLEAR_BIT(GPIOA->PUPDR,  GPIO_PUPDR_PUPDR0);		

	// Configure VFO in input mode
	
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN); 
	CLEAR_BIT(GPIOA->MODER,  GPIO_MODER_MODER11_0);
	CLEAR_BIT(GPIOA->PUPDR,  (GPIO_PUPDR_PUPDR11));
			
	// Configure ITRIP in output push-pull mode
	
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN); 
	CLEAR_BIT(GPIOA->MODER, GPIO_MODER_MODER12);
	SET_BIT(GPIOA->MODER, GPIO_MODER_MODER12_0);
	
	CLEAR_BIT(GPIOA->OTYPER, (GPIO_OTYPER_OT_12));
	SET_BIT(GPIOA->OSPEEDR,  (GPIO_OSPEEDER_OSPEEDR12));
	CLEAR_BIT(GPIOA->PUPDR,   (GPIO_PUPDR_PUPDR12));


}



void init_timer1(void){
  
  NVIC_SetPriority(TIM1_UP_TIM16_IRQn, 1); 
  NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn ); 
	
	// TIM1 clock enable
  RCC->APB2ENR |= RCC_APB2ENR_TIM1EN; 
  
  // Compute the value to be set in ARR register to generate signal frequency at FPWM
  Timer1Period = ((SystemCoreClock / FPWM)/2)-1;
  
	// Auto-reload preload enable 
  TIM1->CR1 |= TIM_CR1_ARPE;  
  
	// 01: Center-aligned mode 1
  TIM1->CR1 |= TIM_CR1_CMS_0; 
  TIM1->CR1 &= ~TIM_CR1_CMS_1;
  
	// Master Mode Selection
  TIM1->CR2 |= TIM_CR2_MMS_1; // 010: Update - The update event is selected as trigger output (TRGO).
	
	// Capture/Compare Preloaded Control
  TIM1->CR2 |= TIM_CR2_CCPC;  
  
	// Output Compare 1,2,3 Preload enable
  TIM1->CCMR1 |= TIM_CCMR1_OC2PE | TIM_CCMR1_OC1PE;
  TIM1->CCMR2 |= TIM_CCMR2_OC3PE;
  
	// TIM auto-reload register
  TIM1->ARR = Timer1Period;
	// TIM prescaler
  TIM1->PSC = 0;
  
	
	//TIM repetition counter register
  TIM1->RCR = 1;
  
	//Update generation
  TIM1->EGR |= TIM_EGR_UG; 
  
	
	// Capture/Compare output enable
  TIM1->CCER |= TIM_CCER_CC1E | TIM_CCER_CC2E | TIM_CCER_CC3E;
  TIM1->CCER |= TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE;

  TIM1->CCMR1 |= 0x0070; //PWM mode 1 
  TIM1->CCMR1 |= 0x7000; //PWM mode 1 
  TIM1->CCMR2 |= 0x0070; //PWM mode 1 

	// TIM capture/compare registers
  TIM1->CCR1 = Timer1Period/2;   
  TIM1->CCR2 = Timer1Period/2;   
  TIM1->CCR3 = Timer1Period/2;   
  
	// Update interrupt enable
  TIM1->DIER |= TIM_DIER_UIE;
  
	// Off-State Selection for Idle mode and for Run mode
  TIM1->BDTR |= TIM_BDTR_OSSI | TIM_BDTR_OSSR;
  
  // Dead time
  //TIM1->BDTR |=0x0080;// 1.78 us
	TIM1->BDTR |=0x006D;// 1.5 us
  
	//Capture/Compare control update generation
  TIM1->EGR |= TIM_EGR_COMG;  
  
	// Main Output enable
  TIM1->BDTR &= ~TIM_BDTR_MOE; 
	
	// Counter enable
  TIM1->CR1 &= ~TIM_CR1_CEN;
  
}



void init_timer2(void){

	NVIC_SetPriority(TIM2_IRQn, 2); 
  NVIC_EnableIRQ(TIM2_IRQn); 
  
  RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	
	TIM2->CR1 |= TIM_CR1_OPM; // One pulse mode
   
  TIM2->SMCR |= TIM_SMCR_SMS_1 | TIM_SMCR_SMS_2; // Slave mode: Trigger Mode
  
  TIM2->DIER |= TIM_DIER_UIE;
  
  TIM2->ARR = 144; // 2 us;
  
  TIM2->PSC = 0;
  
  //TIM2->CR1 |= TIM_CR1_CEN;
	
}



void init_dac(void){
    
	/*DAC channel 1 (DAC_OUT1 = PA.4) configuration*/
	SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DAC1EN);
    /*DAC channel 1 (DAC_OUT1 = PA.4) configuration*/
    SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);
    SET_BIT(GPIOA->MODER, GPIO_MODER_MODER4);        //Analog  PA4
    //GPIOA->MODER          |= GPIO_MODER_MODER5;        //Analog  PA5
    //DAC setup  
    CLEAR_BIT(DAC->CR, DAC_CR_TEN1); //DAC channel1 trigger disabled
    SET_BIT(DAC->CR, DAC_CR_EN1);
  
	
  
}

void init_opamp(void){
	
	// SYSCFG clock enable
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);
	GPIO_InitTypeDef  GPIO_InitStructure;

	/***** OPAMP 1 *****/
	
   /*
			PA3 = OPAMP1_VINM
			PA1 = OPAMP1_VINP
			PA2 = OPAMP1_VOUT
	 */
	
    SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN); 
    SET_BIT(GPIOA->MODER,   GPIO_MODER_MODER1|GPIO_MODER_MODER2|GPIO_MODER_MODER3);
  
  	SET_BIT(OPAMP1->CSR, OPAMP1_CSR_VPSEL); //PA1 used as OPAMP1 non inverting input
	
	SET_BIT(OPAMP1->CSR, OPAMP1_CSR_VMSEL_0); //PA3 (VM1) used as OPAMP1 inverting input
  
    SET_BIT(OPAMP1->CSR, OPAMP1_CSR_OPAMP1EN); //OPAMP1 enable
	
	/***** OPAMP 2 *****/
	
   /*
			PA5 = OPAMP2_VINM
			PA7 = OPAMP2_VINP
			PA6 = OPAMP2_VOUT
	 */
	
    SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);
	SET_BIT(GPIOA->MODER,   GPIO_MODER_MODER5|GPIO_MODER_MODER6|GPIO_MODER_MODER7);
	
	SET_BIT(OPAMP2->CSR, OPAMP2_CSR_VPSEL); //PA7 used as OPAMP2 non inverting input
	
	SET_BIT(OPAMP2->CSR, OPAMP2_CSR_VMSEL_0); //PA5 (VM1) used as OPAMP2 inverting input
  
    SET_BIT(OPAMP2->CSR, OPAMP2_CSR_OPAMP2EN); //OPAMP2 enable
	
	/***** OPAMP 3 *****/
	
   /*
			PB2 = OPAMP3_VINM
			PB0 = OPAMP3_VINP
			PB1 = OPAMP3_VOUT
	 */
	
    SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOBEN);
	SET_BIT(GPIOB->MODER,   GPIO_MODER_MODER0|GPIO_MODER_MODER1|GPIO_MODER_MODER2);
	
	SET_BIT(OPAMP3->CSR, OPAMP3_CSR_VPSEL); //PB0 used as OPAMP3 non inverting input
	
	SET_BIT(OPAMP3->CSR, OPAMP3_CSR_VMSEL_0); //PB2 (VM1) used as OPAMP3 inverting input
  
    SET_BIT(OPAMP3->CSR, OPAMP3_CSR_OPAMP3EN); //OPAMP3 enable
  
	/***** OPAMP 4 *****/
	
   /*
			PB10 = OPAMP4_VINM
			PB11 = OPAMP4_VINP
			PB12 = OPAMP4_VOUT
	 */
	

  
    SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOBEN);
	SET_BIT(GPIOB->MODER,   GPIO_MODER_MODER10|GPIO_MODER_MODER11|GPIO_MODER_MODER12);
	
	SET_BIT(OPAMP4->CSR, OPAMP4_CSR_VPSEL_0); //PB11 used as OPAMP4 non inverting input
	
	CLEAR_BIT(OPAMP4->CSR, OPAMP4_CSR_VMSEL); //PB10 (VM0) used as OPAMP4 inverting input
  
    SET_BIT(OPAMP4->CSR, OPAMP4_CSR_OPAMP4EN); //OPAMP4 enable
	
}

void init_adc(void){
	
	  // ADC1/ ADC2 clock enable
	  RCC->CFGR2 |= RCC_CFGR2_ADCPRE12_DIV2;
    RCC->AHBENR |=  RCC_AHBENR_ADC12EN;
	
		// ADC3/ ADC4 clock enable
		RCC->CFGR2 |= RCC_CFGR2_ADCPRE34_DIV2;
	  RCC->AHBENR |=  RCC_AHBENR_ADC34EN;
	
	
	
		/***** ADC voltage regulator enable *****/
		ADC1->CR 		&= ~ADC_CR_ADVREGEN; 		// 00: Intermediate state 
		ADC1->CR 		|=  ADC_CR_ADVREGEN_0; 	// 01: ADC Voltage regulator enabled.
	
		ADC2->CR 		&= ~ADC_CR_ADVREGEN; 		// 00: Intermediate state 
		ADC2->CR 		|=  ADC_CR_ADVREGEN_0; 	// 01: ADC Voltage regulator enabled.
	
		ADC3->CR 		&= ~ADC_CR_ADVREGEN; 		// 00: Intermediate state 
		ADC3->CR 		|=  ADC_CR_ADVREGEN_0; 	// 01: ADC Voltage regulator enabled.
	
		ADC4->CR 		&= ~ADC_CR_ADVREGEN; 		// 00: Intermediate state 
		ADC4->CR 		|=  ADC_CR_ADVREGEN_0; 	// 01: ADC Voltage regulator enabled.
	
	  DelayMC(10); // Wait for the startup time of the ADC voltage regulator
		
		
	
	  /***** ADC 1 For OPAMP1 *****/
		ADC1->CR 		&= ~ ADC_CR_ADCALDIF; 	// Single-ended inputs Mode
		ADC1->CR 		|=   ADC_CR_ADCAL; 			// ADC calibration
		while(ADC1->CR & ADC_CR_ADCAL); 		// Wait for end of ADC calibration
		
		ADC1->SQR1	|= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_1; // 1st conversion in sequence Channel 3
		
		//ADC1->SMPR1 |= ADC_SMPR1_SMP3_1; // Sampling time = 2.5 ADC clock cycles
		
		//ADC1->CFGR	|= ADC_CFGR_DISCEN; 	// ADC group regular sequencer discontinuous mode
		ADC1->CFGR	|= ADC_CFGR_CONT; 		// ADC group regular continuous conversion mode
		
		ADC1->CFGR	|= ADC_CFGR_DMAEN; 		// ADC DMA enable
		
		ADC1->CFGR	|= ADC_CFGR_EXTEN_0;		// Hardware trigger detection on the rising edge
		ADC1->CFGR	|= ADC_CFGR_EXTSEL_0 | ADC_CFGR_EXTSEL_3; // EXT9 TIM1_TRGO event
		
		ADC1->CR 		|= ADC_CR_ADEN; 						// ADC enable
		while(!(ADC1->ISR & ADC_ISR_ADRDY)){};  // Wait untill ADC is ready to start conversion
			
		ADC1->CR |= ADC_CR_ADSTART; 	//Start ADC Convertion
		
		/***** ADC 1 For THERM *****/
		ADC1->CFGR 	|=  ADC_CFGR_JDISCEN; 	// ADC Discontinuous mode on injected channels		
			
		ADC1->JSQR	|=	ADC_JSQR_JSQ1_0;		// Conversion 1 in the injected sequence Channel 1

		ADC1->JSQR	&= ~ ADC_JSQR_JL;    		// 00: 1 conversion
			
	  /***** ADC 2 For OPAMP2 *****/ 
		ADC2->CR 		&= ~ ADC_CR_ADCALDIF; 	// Single-ended inputs Mode
		ADC2->CR 		|=   ADC_CR_ADCAL; 			// ADC calibration
		while(ADC2->CR & ADC_CR_ADCAL); 		// Wait for end of ADC calibration
		
		ADC2->SQR1	|= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_1; // 1st conversion in sequence Channel 3
			
		//ADC2->CFGR	|= ADC_CFGR_DISCEN; 								// ADC group regular sequencer discontinuous mode
	  ADC2->CFGR	|= ADC_CFGR_CONT; 		// ADC group regular continuous conversion mode

		ADC2->CFGR	|= ADC_CFGR_DMAEN; 		// ADC DMA enable

		ADC2->CFGR	|= ADC_CFGR_EXTEN_0;		// Hardware trigger detection on the rising edge
		ADC2->CFGR	|= ADC_CFGR_EXTSEL_0 | ADC_CFGR_EXTSEL_3; // EXT9 TIM1_TRGO event
		
		ADC2->CR 		|= ADC_CR_ADEN; 						// ADC enable
		while(!(ADC2->ISR & ADC_ISR_ADRDY)){};  // Wait untill ADC is ready to start conversion
			
		ADC2->CR |= ADC_CR_ADSTART; 	//Start ADC Convertion
			

	  /***** ADC 3 For OPAMP3 *****/ 
		ADC3->CR 		&= ~ ADC_CR_ADCALDIF; 	// Single-ended inputs Mode
		ADC3->CR 		|=   ADC_CR_ADCAL; 			// ADC calibration
		while(ADC3->CR & ADC_CR_ADCAL); 		// Wait for end of ADC calibration
		
		ADC3->SQR1	|= ADC_SQR1_SQ1_0; 			// 1st conversion in sequence Channel 1
			
		//ADC3->CFGR	|= ADC_CFGR_DISCEN; 		// ADC group regular sequencer discontinuous mode
		ADC3->CFGR	|= ADC_CFGR_CONT; 		// ADC group regular continuous conversion mode
				
		ADC3->CFGR	|= ADC_CFGR_DMAEN; 		// ADC DMA enable

		ADC3->CFGR	|= ADC_CFGR_EXTEN_0;		// Hardware trigger detection on the rising edge
		ADC3->CFGR	|= ADC_CFGR_EXTSEL_0 | ADC_CFGR_EXTSEL_3; // EXT9 TIM1_TRGO event
			
		//ADC3->IER		|= ADC_IER_EOCIE; 			// ADC group regular end of unitary conversion interrupt
			
		//NVIC_SetPriority(ADC3_IRQn, 2); 
		//NVIC_EnableIRQ(ADC3_IRQn); 
			
		ADC3->CR 		|= ADC_CR_ADEN; 						// ADC enable
		while(!(ADC3->ISR & ADC_ISR_ADRDY)){};  // Wait untill ADC is ready to start conversion
			
		ADC3->CR |= ADC_CR_ADSTART; 	//Start ADC Convertion
			
			

	  /***** ADC 4 For OPAMP4 *****/ 
    ADC4->CR 		&= ~ ADC_CR_ADCALDIF; 	// Single-ended inputs Mode
		ADC4->CR 		|=   ADC_CR_ADCAL; 			// ADC calibration
		while(ADC4->CR & ADC_CR_ADCAL); 		// Wait for end of ADC calibration
		
		ADC4->SQR1	|= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_1; // 1st conversion in sequence Channel 3
			
		//ADC4->CFGR	|= ADC_CFGR_DISCEN; 								// ADC group regular sequencer discontinuous mode
		ADC4->CFGR	|= ADC_CFGR_CONT ; 		// ADC group regular continuous conversion mode
			
		ADC4->CFGR	|= ADC_CFGR_DMAEN; 		// ADC DMA enable
			
		ADC4->CFGR	|= ADC_CFGR_EXTEN_0;		// Hardware trigger detection on the rising edge
		ADC4->CFGR	|= ADC_CFGR_EXTSEL_0 | ADC_CFGR_EXTSEL_3; // EXT9 TIM1_TRGO event
		
		ADC4->CR 		|= ADC_CR_ADEN; 						// ADC enable
		while(!(ADC4->ISR & ADC_ISR_ADRDY)){};  // Wait untill ADC is ready to start conversion
			
		ADC4->CR |= ADC_CR_ADSTART; 	//Start ADC Convertion
         
}

void init_dma(void){
	
	// DMA1 and DMA2 clock enable
	RCC->AHBENR |=  RCC_AHBENR_DMA1EN;
	RCC->AHBENR |=  RCC_AHBENR_DMA2EN;

	/***** DMA1 Channel 1 ADC1 *****/
	
	DMA1_Channel1->CPAR = (uint32_t)&ADC1->DR; // Peripheral address
	DMA1_Channel1->CMAR = (uint32_t)&MasADC.A[0]; // Memory 0 address
	
	DMA1_Channel1->CNDTR = CONVERSIONS_COUNT;									 // Number of data
	
	DMA1_Channel1->CCR	&= ~DMA_CCR_DIR; 			 // Read from peripheral
	DMA1_Channel1->CCR	|=  DMA_CCR_MINC; 		 // Memory increment mode enabled
	
	DMA1_Channel1->CCR	|=  DMA_CCR_PSIZE_1; 	 // Peripheral size = 32-bits
	DMA1_Channel1->CCR	|=  DMA_CCR_MSIZE_1; 	 // Memory size = 32-bits
	
	DMA1_Channel1->CCR	|=  DMA_CCR_PL; 			 // Channel priority level = Very high
	
	DMA1_Channel1->CCR	|=  DMA_CCR_TCIE; 		 // Transfer complete interrupt enable
	
	DMA1_Channel1->CCR	|=  DMA_CCR_CIRC; 		 // Circular mode 
	
	NVIC_SetPriority(DMA1_Channel1_IRQn, 0); 
	NVIC_EnableIRQ(DMA1_Channel1_IRQn); 
	
	DMA1_Channel1->CCR	|=  DMA_CCR_EN ; 			 // Channel enable
	
	
	/***** DMA2 Channel 1 ADC2 *****/
	
	DMA2_Channel1->CPAR = (uint32_t)&ADC2->DR; // Peripheral address
	DMA2_Channel1->CMAR = (uint32_t)&MasADC.B[0]; // Memory 0 address
	
	DMA2_Channel1->CNDTR = CONVERSIONS_COUNT;									 // Number of data
	
	DMA2_Channel1->CCR	&= ~DMA_CCR_DIR; 			 // Read from peripheral
	DMA2_Channel1->CCR	|=  DMA_CCR_MINC; 		 // Memory increment mode enabled
	
	DMA2_Channel1->CCR	|=  DMA_CCR_PSIZE_1; 	 // Peripheral size = 32-bits
	DMA2_Channel1->CCR	|=  DMA_CCR_MSIZE_1; 	 // Memory size = 32-bits
	
	DMA2_Channel1->CCR	|=  DMA_CCR_PL; 			 // Channel priority level = Very high
	//DMA2_Channel1->CCR	|=  DMA_CCR_PL_1; 			 // Channel priority level = High
	
	
	DMA2_Channel1->CCR	|=  DMA_CCR_TCIE; 		 // Transfer complete interrupt enable
		
	DMA2_Channel1->CCR	|=  DMA_CCR_CIRC; 		 // Circular mode 
	
	DMA2_Channel1->CCR	|=  DMA_CCR_EN ; 			 // Channel enable
	
		
	
	/***** DMA2 Channel 5 ADC3 *****/
	
	DMA2_Channel5->CPAR = (uint32_t)&ADC3->DR; // Peripheral address
	DMA2_Channel5->CMAR = (uint32_t)&MasADC.C[0]; // Memory 0 address
	
	DMA2_Channel5->CNDTR = CONVERSIONS_COUNT;									 // Number of data
	
	DMA2_Channel5->CCR	&= ~DMA_CCR_DIR; 			 // Read from peripheral
	DMA2_Channel5->CCR	|=  DMA_CCR_MINC; 		 // Memory increment mode enabled
	
	DMA2_Channel5->CCR	|=  DMA_CCR_PSIZE_1; 	 // Peripheral size = 32-bits
	DMA2_Channel5->CCR	|=  DMA_CCR_MSIZE_1; 	 // Memory size = 32-bits
	
	DMA2_Channel5->CCR	|=  DMA_CCR_PL; 			 // Channel priority level = Very high
	//DMA2_Channel5->CCR	|=  DMA_CCR_PL_1; 		// Channel priority level = High
	
	DMA2_Channel5->CCR	|=  DMA_CCR_TCIE; 		 // Transfer complete interrupt enable
		
	DMA2_Channel5->CCR	|=  DMA_CCR_CIRC; 		 // Circular mode 
	
	DMA2_Channel5->CCR	|=  DMA_CCR_EN ; 			 // Channel enable
	
	
	/***** DMA2 Channel 2 ADC4 *****/
	
	DMA2_Channel2->CPAR = (uint32_t)&ADC4->DR;   // Peripheral address
	DMA2_Channel2->CMAR = (uint32_t)&MasADC.VDC[0]; // Memory 0 address
	
	DMA2_Channel2->CNDTR = CONVERSIONS_COUNT;									 // Number of data
	
	DMA2_Channel2->CCR	&= ~DMA_CCR_DIR; 			 // Read from peripheral
	DMA2_Channel2->CCR	|=  DMA_CCR_MINC; 		 // Memory increment mode enabled
	
	DMA2_Channel2->CCR	|=  DMA_CCR_PSIZE_1; 	 // Peripheral size = 32-bits
	DMA2_Channel2->CCR	|=  DMA_CCR_MSIZE_1; 	 // Memory size = 32-bits
	
	DMA2_Channel2->CCR	|=  DMA_CCR_PL; 			 // Channel priority level = Very high
	//DMA2_Channel2->CCR	|=  DMA_CCR_PL_0;			 // Channel priority level = Medium
	
	DMA2_Channel2->CCR	|=  DMA_CCR_TCIE; 		 // Transfer complete interrupt enable
		
	DMA2_Channel2->CCR	|=  DMA_CCR_CIRC; 		 // Circular mode 
	
	DMA2_Channel2->CCR	|=  DMA_CCR_EN ; 			 // Channel enable

}

